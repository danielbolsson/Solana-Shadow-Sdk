# Multi-Party Trusted Setup Ceremony

## Overview

The trusted setup is a critical cryptographic ceremony required for Groth16 ZK-SNARKs. It generates proving and verification keys that enable zero-knowledge proofs while maintaining security.

## ⚠️ Why This Matters

**Current Status**: The circuit keys in this repository were generated by a single party (development keys). This means:
- ❌ The generator knows the "toxic waste" (secret randomness)
- ❌ They could potentially create fake proofs
- ❌ **NOT SAFE FOR PRODUCTION**

**After MPC Ceremony**: Keys generated by multiple independent parties where:
- ✅ Only ONE honest participant is needed for security
- ✅ No single party knows the toxic waste
- ✅ **SAFE FOR PRODUCTION** (if at least 1 participant is honest)

## Ceremony Process

### Phase 1: Preparation

#### 1.1 Finalize Circuits
```bash
# Ensure all circuits are final and audited
cd circuits/

# Compile production circuits
circom transfer.circom --r1cs --wasm --sym
circom balance.circom --r1cs --wasm --sym
circom ring_signature.circom --r1cs --wasm --sym

# Verify circuit constraints
snarkjs r1cs info transfer.r1cs
snarkjs r1cs info balance.r1cs
snarkjs r1cs info ring_signature.r1cs
```

#### 1.2 Select Participants
Choose **diverse, independent participants**:
- Minimum: 3-5 participants
- Recommended: 10-20 participants
- Best practice: 50+ participants (like Zcash Powers of Tau)

Ideal participants:
- Core team members
- Independent auditors
- Community members from different countries
- Organizations with good security practices
- Anonymous participants (for added safety)

#### 1.3 Setup Ceremony Coordinator
The coordinator:
- Does NOT participate in the ceremony (to avoid bias)
- Manages the ceremony workflow
- Verifies contributions
- Publishes final keys

### Phase 2: Powers of Tau (Phase 1 Ceremony)

This generates universal parameters that can be reused across circuits.

#### 2.1 Initialize Powers of Tau
```bash
# Coordinator starts the ceremony
snarkjs powersoftau new bn128 20 pot20_0000.ptau -v

# 20 = circuit size (2^20 constraints)
# Adjust based on your largest circuit
```

#### 2.2 Participant Contributions

**Participant 1:**
```bash
# Download initial params
wget https://ceremony.example.com/pot20_0000.ptau

# Contribute randomness
snarkjs powersoftau contribute pot20_0000.ptau pot20_0001.ptau \
  --name="Participant 1" \
  -v -e="$(head -c 1024 /dev/urandom | sha256sum | head -c 64)"

# Upload contribution
# Hash: pot20_0001.ptau -> SHA256 checksum

# DESTROY local randomness (critical!)
shred -vfz -n 10 pot20_0000.ptau
```

**Participant 2-N:**
```bash
# Download previous contribution
wget https://ceremony.example.com/pot20_000X.ptau

# Add your contribution
snarkjs powersoftau contribute pot20_000X.ptau pot20_000Y.ptau \
  --name="Participant N" \
  -v -e="$(head -c 1024 /dev/urandom | sha256sum | head -c 64)"

# Upload and verify
# DESTROY previous files
shred -vfz -n 10 pot20_000X.ptau
```

#### 2.3 Verify Contributions
```bash
# Coordinator verifies each contribution
snarkjs powersoftau verify pot20_000Y.ptau

# Check contribution attestations
# Ensure each participant followed protocol
```

#### 2.4 Apply Random Beacon
```bash
# Use public randomness source (e.g., Bitcoin block hash, DRAND)
# This prevents last participant from having undue influence

# Get beacon value (example: Bitcoin block hash at height X)
BEACON="000000000000000000024bead8df69990852c202db0e0097c1a12ea637d7e96d"

snarkjs powersoftau beacon pot20_FINAL.ptau pot20_beacon.ptau \
  $BEACON 10 -n="Final Beacon"
```

#### 2.5 Prepare Phase 2
```bash
# Prepare for circuit-specific setup
snarkjs powersoftau prepare phase2 pot20_beacon.ptau pot20_final.ptau -v

# Verify final parameters
snarkjs powersoftau verify pot20_final.ptau
```

### Phase 3: Circuit-Specific Setup (Phase 2 Ceremony)

Generate keys for each circuit.

#### 3.1 Transfer Circuit Setup

**Initialize:**
```bash
# Coordinator starts Phase 2
snarkjs groth16 setup transfer.r1cs pot20_final.ptau transfer_0000.zkey
```

**Participant Contributions:**
```bash
# Participant 1
snarkjs zkey contribute transfer_0000.zkey transfer_0001.zkey \
  --name="Participant 1 Transfer" \
  -v -e="$(head -c 1024 /dev/urandom | sha256sum | head -c 64)"

# Participant 2-N
snarkjs zkey contribute transfer_000X.zkey transfer_000Y.zkey \
  --name="Participant N Transfer" \
  -v -e="$(head -c 1024 /dev/urandom | sha256sum | head -c 64)"

# CRITICAL: Destroy local files after each step
shred -vfz -n 10 transfer_000X.zkey
```

**Apply Beacon:**
```bash
# Use same or different beacon
snarkjs zkey beacon transfer_FINAL.zkey transfer_beacon.zkey \
  $BEACON 10 -n="Transfer Final Beacon"
```

**Verify and Export:**
```bash
# Verify the final key
snarkjs zkey verify transfer.r1cs pot20_final.ptau transfer_beacon.zkey

# Export verification key
snarkjs zkey export verificationkey transfer_beacon.zkey transfer_verification_key.json

# Rename to production keys
mv transfer_beacon.zkey transfer_final.zkey
```

#### 3.2 Balance Circuit Setup

Repeat the same process for `balance.circom`:
```bash
snarkjs groth16 setup balance.r1cs pot20_final.ptau balance_0000.zkey
# ... participant contributions ...
snarkjs zkey beacon balance_FINAL.zkey balance_final.zkey $BEACON 10
snarkjs zkey verify balance.r1cs pot20_final.ptau balance_final.zkey
snarkjs zkey export verificationkey balance_final.zkey balance_verification_key.json
```

#### 3.3 Ring Signature Circuit Setup

Repeat for `ring_signature.circom`:
```bash
snarkjs groth16 setup ring_signature.r1cs pot20_final.ptau ring_sig_0000.zkey
# ... participant contributions ...
snarkjs zkey beacon ring_sig_FINAL.zkey ring_sig_final.zkey $BEACON 10
snarkjs zkey verify ring_signature.r1cs pot20_final.ptau ring_sig_final.zkey
snarkjs zkey export verificationkey ring_sig_final.zkey ring_signature_verification_key.json
```

### Phase 4: Publication and Verification

#### 4.1 Publish Ceremony Artifacts
```bash
# Upload to IPFS and permanent storage
ipfs add transfer_final.zkey
ipfs add balance_final.zkey
ipfs add ring_sig_final.zkey
ipfs add pot20_final.ptau

# Publish hashes and attestations
# Example:
# transfer_final.zkey: QmXXXXXXXXXXXXXXXXXXX...
# SHA256: abc123def456...
```

#### 4.2 Participant Attestations
Each participant should publish:
```
I, [Name], participated in the Shadow Privacy Trusted Setup Ceremony.
- Contribution: Phase 1 #5, Phase 2 Transfer #3
- Randomness source: /dev/urandom + physical dice rolls
- Entropy hash: sha256(...)
- I destroyed all local copies of intermediate parameters
- Attestation signature: [GPG signature]
```

#### 4.3 Coordinator Final Report
```markdown
# Shadow Privacy Trusted Setup - Final Report

## Ceremony Details
- Date: 2024-XX-XX to 2024-XX-XX
- Participants: 15 independent parties
- Beacon: Bitcoin block #XXXXXX (hash: 0x...)

## Final Parameters
- Powers of Tau: ipfs://QmXXX... (SHA256: ...)
- Transfer Circuit: ipfs://QmYYY... (SHA256: ...)
- Balance Circuit: ipfs://QmZZZ... (SHA256: ...)
- Ring Signature: ipfs://QmAAA... (SHA256: ...)

## Verification
All parameters verified with:
- snarkjs powersoftau verify
- snarkjs zkey verify

## Participants
1. Alice (alice@example.com) - Phase 1 #1, All Phase 2 #1
2. Bob (bob@example.com) - Phase 1 #2, Transfer #2
...

Security assumption: At least ONE participant was honest and destroyed their toxic waste.
```

## Best Practices

### For Participants

**DO:**
- ✅ Use high-quality randomness sources
- ✅ Run ceremony on air-gapped machine (recommended)
- ✅ Verify previous contributions before adding yours
- ✅ **DESTROY all intermediate files** after contribution
- ✅ Publish attestation with GPG signature
- ✅ Use unique randomness for each circuit

**DON'T:**
- ❌ Reuse randomness across contributions
- ❌ Keep copies of intermediate parameters
- ❌ Run ceremony on compromised machines
- ❌ Trust previous participants without verification

### For Coordinator

**DO:**
- ✅ Verify each contribution immediately
- ✅ Publish running hash chain of contributions
- ✅ Use time-locked beacons (future block hashes)
- ✅ Keep ceremony website/repository updated
- ✅ Archive all attestations

**DON'T:**
- ❌ Participate in your own ceremony
- ❌ Rush the process
- ❌ Accept contributions without verification

## Security Considerations

### Threat Model

**What the ceremony protects against:**
- Malicious key generation by single party
- Fake proofs created with knowledge of toxic waste

**What it does NOT protect against:**
- Bugs in the circuit logic (requires audit)
- Implementation vulnerabilities (requires code review)
- Side-channel attacks on proof generation

### Randomness Quality

Good entropy sources (in order of preference):
1. **Hardware RNG** (TPM, Intel DRNG)
2. **Physical randomness** (dice, coin flips, atmospheric noise)
3. **Cryptographic RNG** (/dev/urandom on Linux)
4. **Combined sources** (mix multiple sources with XOR)

Poor entropy sources (AVOID):
- ❌ Keyboard timing alone
- ❌ Mouse movements
- ❌ Predictable seeds (timestamps, usernames)

## Verification for Users

Anyone can verify the ceremony was performed correctly:

```bash
# 1. Download published parameters
wget https://setup.ghostprivacy.io/transfer_final.zkey
wget https://setup.ghostprivacy.io/pot20_final.ptau
wget https://setup.ghostprivacy.io/transfer.r1cs

# 2. Verify integrity
snarkjs zkey verify transfer.r1cs pot20_final.ptau transfer_final.zkey

# 3. Check beacon was used correctly
snarkjs zkey export json transfer_final.zkey transfer_key.json
# Inspect contribution hashes and beacon value

# 4. Verify against blockchain
# Check that beacon matches public randomness source
```

## Tools and Resources

- **snarkjs**: https://github.com/iden3/snarkjs
- **Zcash Ceremony**: https://zfnd.org/conclusion-of-the-sapling-mpc/
- **Perpetual Powers of Tau**: https://github.com/weijiekoh/perpetualpowersoftau
- **DRAND Beacon**: https://drand.love/

## Timeline Example

| Week | Activity |
|------|----------|
| 0 | Finalize circuits, audit, select participants |
| 1 | Phase 1 Powers of Tau (5-10 participants) |
| 2 | Apply beacon, verify Phase 1 |
| 3 | Phase 2 Transfer circuit (5-10 participants) |
| 4 | Phase 2 Balance circuit (5-10 participants) |
| 5 | Phase 2 Ring Signature circuit (5-10 participants) |
| 6 | Apply beacons, final verification |
| 7 | Publish parameters, collect attestations |
| 8 | Deploy to production |

## Post-Ceremony

### Deploy Verification Keys
```bash
# Upload VKs to Solana program
cd privacy-integration
npx ts-node store-verification-keys.ts
```

### Archive Ceremony Data
- Store all attestations in repository
- Publish ceremony transcript
- Archive on IPFS and Arweave
- Create permanent record

## Conclusion

A properly executed MPC ceremony is the foundation of trust for the Shadow Privacy protocol. With diverse, independent participants and proper randomness, the protocol achieves cryptographic security without trusting any single party.

**Remember: Only ONE honest participant is needed for security.**
